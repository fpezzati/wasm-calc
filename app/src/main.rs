use wasmtime::component::{bindgen, Component, Linker};
use wasmtime::{Config, Engine, Store};
use wasmtime_wasi::{ResourceTable, WasiCtx, WasiCtxBuilder, WasiView};

fn main() {
    println!("Hello, world!");

    //package calc:operator;
    //
    //world operator {
    //    export compute: func(x: s32, y: s32) -> s32;
    //    export name: func() -> string;
    //}

    bindgen!({ world: "operator", path: "./wit/operator.wit", async: false });

    let mut config = Config::default();
    config.wasm_component_model(true);
    let engine = Engine::new(&config).unwrap();
    let mut wasi_ctx_builder = WasiCtxBuilder::new();
    // Construct component
    let component = Component::from_file(
        &engine,
        "/home/fpezzati/workspace/wasm-calc/add/target/wasm32-wasip2/release/add.wasm",
    )
    .expect("Component file not found");
    // Construct store for storing running states of the component
    let mut store = Store::new(
        &engine,
        ComponentState {
            ctx: wasi_ctx_builder.build(),
            table: ResourceTable::new(),
        },
    );
    // Construct linker for linking interfaces.
    // For this simple adder component, no need to link additional interfaces.
    let mut linker = Linker::new(&engine);
    wasmtime_wasi::add_to_linker_sync(&mut linker);
    // Operator is an autogenerated binding struct by macro 'bindgen!'
    let instance = Operator::instantiate(&mut store, &component, &linker)
        .expect("Failed to instantiate component");
    let name = instance.call_name(&mut store).unwrap();

    println!("operator name: {}", name);
}

struct ComponentState {
    ctx: WasiCtx,
    table: ResourceTable,
}

impl WasiView for ComponentState {
    fn table(&mut self) -> &mut ResourceTable {
        &mut self.table
    }
    fn ctx(&mut self) -> &mut WasiCtx {
        &mut self.ctx
    }
}
