use wasmtime::component::{bindgen, Component, Linker, ResourceTable};
use wasmtime::{Config, Engine, Store};
use wasmtime_wasi::{WasiCtx, WasiCtxBuilder, WasiView};

fn main() {
    println!("Hello, world!");

    //package calc:operator;
    //
    //world operator {
    //    export compute: func(x: s32, y: s32) -> s32;
    //    export name: func() -> string;
    //}

    bindgen!({ world: "operator", path: "./wit/operator.wit", async: false });

    let mut config = Config::default();
    config.async_support(true);
    let engine = Engine::new(&config).unwrap();
    let mut wasi_ctx_builder = WasiCtxBuilder::new();
    // Construct component
    let component = Component::from_file(
        &engine,
        "/home/fpezzati/workspace/wasm-calc/add/target/wasm32-wasip1/release/add.wasm",
    )
    .expect("Component file not found");
    // Construct store for storing running states of the component
    let mut store = Store::new(
        &engine,
        ComponentState {
            ctx: wasi_ctx_builder.build(),
            table: ResourceTable::new(),
        },
    );
    // Construct linker for linking interfaces.
    // For this simple adder component, no need to link additional interfaces.
    let linker = Linker::new(&engine);
    // Operator is an autogenerated binding struct by macro 'bindgen!'
    let instance = Operator::instantiate(&mut store, &component, &linker)
        .expect("Failed to instantiate component");

    println!("operator name: {}", instance.call_name(&mut store).unwrap());
}

struct ComponentState {
    ctx: WasiCtx,
    table: ResourceTable,
}

impl WasiView for ComponentState {
    fn table(&mut self) -> &mut ResourceTable {
        &mut self.table
    }
    fn ctx(&mut self) -> &mut WasiCtx {
        &mut self.ctx
    }
}
